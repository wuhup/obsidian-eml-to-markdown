/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EmlToMarkdownPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// eml-parser.ts
function parseEmailAddress(str) {
  str = str.trim();
  const match = str.match(/^"?([^"<]*)"?\s*<([^>]+)>$/);
  if (match) {
    return {
      name: match[1].trim().replace(/^"|"$/g, ""),
      address: match[2].trim()
    };
  }
  return {
    name: "",
    address: str
  };
}
function parseEmailAddresses(str) {
  if (!str)
    return [];
  const addresses = [];
  let current = "";
  let inQuotes = false;
  let inAngleBrackets = false;
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === '"' && str[i - 1] !== "\\") {
      inQuotes = !inQuotes;
    } else if (char === "<" && !inQuotes) {
      inAngleBrackets = true;
    } else if (char === ">" && !inQuotes) {
      inAngleBrackets = false;
    } else if (char === "," && !inQuotes && !inAngleBrackets) {
      if (current.trim()) {
        addresses.push(parseEmailAddress(current));
      }
      current = "";
      continue;
    }
    current += char;
  }
  if (current.trim()) {
    addresses.push(parseEmailAddress(current));
  }
  return addresses;
}
function decodeMimeWord(str) {
  return str.replace(/=\?([^?]+)\?([BQ])\?([^?]+)\?=/gi, (match, charset, encoding, text) => {
    try {
      const nodeCharset = normalizeCharset(charset);
      if (encoding.toUpperCase() === "B") {
        return Buffer.from(text, "base64").toString(nodeCharset);
      } else if (encoding.toUpperCase() === "Q") {
        const withSpaces = text.replace(/_/g, " ");
        const bytes = [];
        let i = 0;
        while (i < withSpaces.length) {
          if (withSpaces[i] === "=" && i + 2 < withSpaces.length) {
            const hex = withSpaces.substring(i + 1, i + 3);
            if (/^[0-9A-Fa-f]{2}$/.test(hex)) {
              bytes.push(parseInt(hex, 16));
              i += 3;
              continue;
            }
          }
          bytes.push(withSpaces.charCodeAt(i));
          i++;
        }
        return Buffer.from(bytes).toString(nodeCharset);
      }
    } catch (e) {
    }
    return match;
  });
}
function decodeQuotedPrintableToBuffer(str) {
  const withoutSoftBreaks = str.replace(/=\r?\n/g, "");
  const bytes = [];
  let i = 0;
  while (i < withoutSoftBreaks.length) {
    if (withoutSoftBreaks[i] === "=" && i + 2 < withoutSoftBreaks.length) {
      const hex = withoutSoftBreaks.substring(i + 1, i + 3);
      if (/^[0-9A-Fa-f]{2}$/.test(hex)) {
        bytes.push(parseInt(hex, 16));
        i += 3;
        continue;
      }
    }
    bytes.push(withoutSoftBreaks.charCodeAt(i));
    i++;
  }
  return Buffer.from(bytes);
}
function decodeQuotedPrintable(str, charset = "utf-8") {
  const buffer = decodeQuotedPrintableToBuffer(str);
  try {
    return buffer.toString(charset);
  } catch (e) {
    return str.replace(/=\r?\n/g, "");
  }
}
function decodeBase64(str, charset = "utf-8") {
  try {
    return Buffer.from(str.replace(/\s/g, ""), "base64").toString(charset);
  } catch (e) {
    return str;
  }
}
function parseHeaders(headerText) {
  const headers = /* @__PURE__ */ new Map();
  const unfoldedText = headerText.replace(/\r?\n[\t ]+/g, " ");
  const lines = unfoldedText.split(/\r?\n/);
  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex > 0) {
      const key = line.substring(0, colonIndex).trim().toLowerCase();
      const value = decodeMimeWord(line.substring(colonIndex + 1).trim());
      headers.set(key, value);
    }
  }
  return headers;
}
function extractBoundary(contentType) {
  const match = contentType.match(/boundary\s*=\s*"?([^";]+)"?/i);
  return match ? match[1] : null;
}
function getEncoding(headers) {
  return (headers.get("content-transfer-encoding") || "7bit").toLowerCase();
}
function getContentType(headers) {
  const ct = headers.get("content-type") || "text/plain";
  return ct.split(";")[0].trim().toLowerCase();
}
function normalizeCharset(charset) {
  const lower = charset.toLowerCase().replace(/[^a-z0-9]/g, "");
  if (lower === "iso88591" || lower === "latin1" || lower === "windows1252" || lower === "cp1252" || lower === "iso885915") {
    return "latin1";
  }
  if (lower === "usascii" || lower === "ascii") {
    return "ascii";
  }
  return "utf-8";
}
function getCharset(headers) {
  const ct = headers.get("content-type") || "";
  const match = ct.match(/charset\s*=\s*"?([^";]+)"?/i);
  return match ? normalizeCharset(match[1]) : "utf-8";
}
function getFilename(headers) {
  const disposition = headers.get("content-disposition") || "";
  const contentType = headers.get("content-type") || "";
  let match = disposition.match(/filename\*?=\s*(?:utf-8'')?["']?([^"';\r\n]+)["']?/i);
  if (match) {
    return decodeMimeWord(decodeURIComponent(match[1]));
  }
  match = contentType.match(/name\s*=\s*"?([^";]+)"?/i);
  if (match) {
    return decodeMimeWord(match[1]);
  }
  return null;
}
function decodeContent(content, encoding, charset = "utf-8") {
  switch (encoding) {
    case "base64":
      return decodeBase64(content, charset);
    case "quoted-printable":
      return decodeQuotedPrintable(content, charset);
    default:
      return content;
  }
}
function decodeContentToBuffer(content, encoding) {
  switch (encoding) {
    case "base64":
      return Buffer.from(content.replace(/\s/g, ""), "base64");
    case "quoted-printable":
      return decodeQuotedPrintableToBuffer(content);
    default:
      return Buffer.from(content, "binary");
  }
}
function parseMimePart(partText, result, isTopLevel = false) {
  var _a;
  const headerEndIndex = partText.search(/\r?\n\r?\n/);
  if (headerEndIndex === -1) {
    return;
  }
  const headerText = partText.substring(0, headerEndIndex);
  const bodyText = partText.substring(headerEndIndex).replace(/^\r?\n\r?\n/, "");
  const headers = parseHeaders(headerText);
  const contentType = getContentType(headers);
  const encoding = getEncoding(headers);
  const charset = getCharset(headers);
  if (contentType.startsWith("multipart/")) {
    const boundary = extractBoundary(headers.get("content-type") || "");
    if (boundary) {
      const parts = bodyText.split(new RegExp(`--${escapeRegex(boundary)}(?:--)?`));
      for (let i = 1; i < parts.length - 1; i++) {
        const part = parts[i].trim();
        if (part && part !== "--") {
          parseMimePart(part, result);
        }
      }
    }
    return;
  }
  if (contentType === "text/plain") {
    const decoded = decodeContent(bodyText, encoding, charset);
    if (!result.textBody) {
      result.textBody = decoded;
    }
    return;
  }
  if (contentType === "text/html") {
    const decoded = decodeContent(bodyText, encoding, charset);
    if (!result.htmlBody) {
      result.htmlBody = decoded;
    }
    return;
  }
  const disposition = headers.get("content-disposition") || "";
  const filename = getFilename(headers);
  if (filename || disposition.includes("attachment") || !contentType.startsWith("text/") && !contentType.startsWith("multipart/")) {
    const attachment = {
      filename: filename || `attachment_${result.attachments.length + 1}`,
      contentType,
      content: decodeContentToBuffer(bodyText, encoding),
      contentId: (_a = headers.get("content-id")) == null ? void 0 : _a.replace(/[<>]/g, "")
    };
    result.attachments.push(attachment);
  }
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function isSafeUrl(url) {
  const trimmed = url.trim().toLowerCase();
  return trimmed.startsWith("http://") || trimmed.startsWith("https://") || trimmed.startsWith("mailto:") || trimmed.startsWith("cid:");
}
function sanitizeUrl(url) {
  return isSafeUrl(url) ? url : "";
}
function htmlToMarkdown(html) {
  return html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "").replace(/<h1[^>]*>(.*?)<\/h1>/gi, "# $1\n\n").replace(/<h2[^>]*>(.*?)<\/h2>/gi, "## $1\n\n").replace(/<h3[^>]*>(.*?)<\/h3>/gi, "### $1\n\n").replace(/<h4[^>]*>(.*?)<\/h4>/gi, "#### $1\n\n").replace(/<h5[^>]*>(.*?)<\/h5>/gi, "##### $1\n\n").replace(/<h6[^>]*>(.*?)<\/h6>/gi, "###### $1\n\n").replace(/<strong[^>]*>(.*?)<\/strong>/gi, "**$1**").replace(/<b[^>]*>(.*?)<\/b>/gi, "**$1**").replace(/<em[^>]*>(.*?)<\/em>/gi, "*$1*").replace(/<i[^>]*>(.*?)<\/i>/gi, "*$1*").replace(/<a[^>]+href="([^"]*)"[^>]*>(.*?)<\/a>/gi, (match, url, text) => {
    const safeUrl = sanitizeUrl(url);
    return safeUrl ? `[${text}](${safeUrl})` : text;
  }).replace(/<img[^>]+src="([^"]*)"[^>]*alt="([^"]*)"[^>]*\/?>/gi, (match, url, alt) => {
    const safeUrl = sanitizeUrl(url);
    return safeUrl ? `![${alt}](${safeUrl})` : alt;
  }).replace(/<img[^>]+src="([^"]*)"[^>]*\/?>/gi, (match, url) => {
    const safeUrl = sanitizeUrl(url);
    return safeUrl ? `![](${safeUrl})` : "";
  }).replace(/<ul[^>]*>/gi, "\n").replace(/<\/ul>/gi, "\n").replace(/<ol[^>]*>/gi, "\n").replace(/<\/ol>/gi, "\n").replace(/<li[^>]*>(.*?)<\/li>/gi, "- $1\n").replace(/<br\s*\/?>/gi, "\n").replace(/<\/p>/gi, "\n\n").replace(/<p[^>]*>/gi, "").replace(/<\/div>/gi, "\n").replace(/<div[^>]*>/gi, "").replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, (match, content) => {
    return content.split("\n").map((line) => "> " + line).join("\n") + "\n\n";
  }).replace(/<code[^>]*>(.*?)<\/code>/gi, "`$1`").replace(/<pre[^>]*>(.*?)<\/pre>/gis, "```\n$1\n```\n\n").replace(/<hr[^>]*\/?>/gi, "\n---\n\n").replace(/<\/tr>/gi, "|\n").replace(/<\/th>/gi, " | ").replace(/<\/td>/gi, " | ").replace(/<tr[^>]*>/gi, "|").replace(/<th[^>]*>/gi, "").replace(/<td[^>]*>/gi, "").replace(/<\/?table[^>]*>/gi, "\n").replace(/<\/?thead[^>]*>/gi, "").replace(/<\/?tbody[^>]*>/gi, "").replace(/<[^>]+>/g, "").replace(/&nbsp;/g, " ").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(parseInt(dec, 10))).replace(/&#x([0-9A-Fa-f]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16))).replace(/\n{3,}/g, "\n\n").trim();
}
function parseEml(content) {
  const result = {
    from: [],
    to: [],
    cc: [],
    bcc: [],
    subject: "",
    date: null,
    messageId: "",
    textBody: "",
    htmlBody: "",
    attachments: []
  };
  const headerEndIndex = content.search(/\r?\n\r?\n/);
  if (headerEndIndex === -1) {
    return result;
  }
  const headerText = content.substring(0, headerEndIndex);
  const bodyText = content.substring(headerEndIndex).replace(/^\r?\n\r?\n/, "");
  const headers = parseHeaders(headerText);
  result.from = parseEmailAddresses(headers.get("from") || "");
  result.to = parseEmailAddresses(headers.get("to") || "");
  result.cc = parseEmailAddresses(headers.get("cc") || "");
  result.bcc = parseEmailAddresses(headers.get("bcc") || "");
  result.subject = headers.get("subject") || "";
  result.messageId = (headers.get("message-id") || "").replace(/[<>]/g, "");
  const dateStr = headers.get("date");
  if (dateStr) {
    try {
      result.date = new Date(dateStr);
    } catch (e) {
      result.date = null;
    }
  }
  const contentType = getContentType(headers);
  const encoding = getEncoding(headers);
  const charset = getCharset(headers);
  if (contentType.startsWith("multipart/")) {
    const boundary = extractBoundary(headers.get("content-type") || "");
    if (boundary) {
      const parts = bodyText.split(new RegExp(`--${escapeRegex(boundary)}(?:--)?`));
      for (let i = 1; i < parts.length; i++) {
        const part = parts[i].trim();
        if (part && part !== "--") {
          parseMimePart(part, result);
        }
      }
    }
  } else if (contentType === "text/plain") {
    result.textBody = decodeContent(bodyText, encoding, charset);
  } else if (contentType === "text/html") {
    result.htmlBody = decodeContent(bodyText, encoding, charset);
  }
  return result;
}
function formatEmailAddress(addr) {
  if (addr.name) {
    return `${addr.name} <${addr.address}>`;
  }
  return addr.address;
}
function formatEmailAddresses(addrs) {
  return addrs.map(formatEmailAddress).join(", ");
}

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  autoConvert: true,
  emlHandling: "move-to-attachments",
  linkMovedEml: true,
  useFrontmatter: true,
  dateFormat: "YYYY-MM-DD HH:mm",
  showHeadersInBody: true,
  attachmentListPosition: "both"
};
var EmlToMarkdownSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Auto-convert").setDesc("Automatically convert .eml files when they are added to the vault.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoConvert).onChange(async (value) => {
      this.plugin.settings.autoConvert = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("EML file handling").setDesc("What to do with the original .eml file after conversion.").addDropdown((dropdown) => dropdown.addOption("keep", "Keep in place").addOption("delete", "Delete").addOption("move-to-attachments", "Move to attachments folder").setValue(this.plugin.settings.emlHandling).onChange(async (value) => {
      this.plugin.settings.emlHandling = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.emlHandling === "move-to-attachments") {
      new import_obsidian.Setting(containerEl).setName("Link moved EML").setDesc("Include a link to the moved .eml file in the generated Markdown.").addToggle((toggle) => toggle.setValue(this.plugin.settings.linkMovedEml).onChange(async (value) => {
        this.plugin.settings.linkMovedEml = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(containerEl).setName("Use frontmatter").setDesc("Include email metadata as YAML frontmatter in the generated Markdown file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.useFrontmatter).onChange(async (value) => {
      this.plugin.settings.useFrontmatter = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show headers in body").setDesc("Display From/To/Date headers in the note body in addition to frontmatter.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showHeadersInBody).onChange(async (value) => {
      this.plugin.settings.showHeadersInBody = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Attachment list position").setDesc("Where to show the list of attachments in the generated note.").addDropdown((dropdown) => dropdown.addOption("top", "Top (after headers)").addOption("bottom", "Bottom (after body)").addOption("both", "Both top and bottom").setValue(this.plugin.settings.attachmentListPosition).onChange(async (value) => {
      this.plugin.settings.attachmentListPosition = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date format").setDesc("Format for displaying dates. Use YYYY for year, MM for month, DD for day, HH for hour, mm for minute.").addText((text) => text.setPlaceholder("YYYY-MM-DD HH:mm").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value || DEFAULT_SETTINGS.dateFormat;
      await this.plugin.saveSettings();
    }));
  }
};

// main.ts
var MAX_ATTACHMENT_SIZE = 500 * 1024 * 1024;
var EmlToMarkdownPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    // Track files currently being processed to prevent loops
    this.processingFiles = /* @__PURE__ */ new Set();
  }
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (this.settings.autoConvert && file instanceof import_obsidian2.TFile && file.extension === "eml") {
          if (this.processingFiles.has(file.path) || this.isInAttachmentsFolder(file)) {
            return;
          }
          setTimeout(() => this.convertEmlFile(file), 500);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (this.settings.autoConvert && file instanceof import_obsidian2.TFile && file.extension === "eml") {
          const wasEml = oldPath.toLowerCase().endsWith(".eml");
          if (this.processingFiles.has(file.path) || this.isInAttachmentsFolder(file) || wasEml) {
            return;
          }
          setTimeout(() => this.convertEmlFile(file), 500);
        }
      })
    );
    this.addCommand({
      id: "convert-eml-to-markdown",
      name: "Convert EML file to Markdown",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "eml") {
          if (!checking) {
            this.convertEmlFile(activeFile);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "convert-all-eml-to-markdown",
      name: "Convert all EML files in vault to Markdown",
      callback: async () => {
        const emlFiles = this.app.vault.getFiles().filter((f) => f.extension === "eml");
        if (emlFiles.length === 0) {
          new import_obsidian2.Notice("No .eml files found in vault");
          return;
        }
        new import_obsidian2.Notice(`Converting ${emlFiles.length} EML file(s)...`);
        let converted = 0;
        let failed = 0;
        for (const file of emlFiles) {
          try {
            await this.convertEmlFile(file);
            converted++;
          } catch (e) {
            failed++;
            console.error(`EML conversion failed for ${file.path}:`, e);
          }
        }
        new import_obsidian2.Notice(`Converted ${converted} EML file(s). ${failed > 0 ? `${failed} failed.` : ""}`);
      }
    });
    this.addSettingTab(new EmlToMarkdownSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Get the attachment folder path based on Obsidian settings
   */
  getAttachmentFolder(sourceFile) {
    const attachmentFolderPath = this.app.vault.getConfig("attachmentFolderPath");
    if (!attachmentFolderPath || attachmentFolderPath === "/") {
      return "";
    }
    if (attachmentFolderPath.startsWith("./")) {
      const folder = sourceFile.parent;
      return folder ? (0, import_obsidian2.normalizePath)(folder.path + "/" + attachmentFolderPath.substring(2)) : attachmentFolderPath.substring(2);
    }
    return attachmentFolderPath;
  }
  /**
   * Check if a file is in an attachments folder
   */
  isInAttachmentsFolder(file) {
    const attachmentFolderPath = this.app.vault.getConfig("attachmentFolderPath");
    if (!attachmentFolderPath || attachmentFolderPath === "/") {
      return false;
    }
    if (attachmentFolderPath.startsWith("./")) {
      const folderName = attachmentFolderPath.substring(2);
      return file.path.includes("/" + folderName + "/") || file.path.startsWith(folderName + "/");
    }
    return file.path.startsWith(attachmentFolderPath + "/") || file.path.startsWith(attachmentFolderPath);
  }
  /**
   * Ensure a folder exists, creating it and any parent folders if necessary
   */
  async ensureFolderExists(folderPath) {
    if (!folderPath)
      return;
    const normalizedPath = (0, import_obsidian2.normalizePath)(folderPath);
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (folder)
      return;
    const parts = normalizedPath.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const existingFolder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!existingFolder) {
        try {
          await this.app.vault.createFolder(currentPath);
        } catch (e) {
          if (!this.app.vault.getAbstractFileByPath(currentPath)) {
            throw e;
          }
        }
      }
    }
  }
  /**
   * Convert an EML file to Markdown
   */
  async convertEmlFile(file) {
    if (this.processingFiles.has(file.path)) {
      return;
    }
    this.processingFiles.add(file.path);
    try {
      const mdPath = file.path.replace(/\.eml$/i, ".md");
      const existingMd = this.app.vault.getAbstractFileByPath(mdPath);
      if (existingMd) {
        return;
      }
      if (this.isInAttachmentsFolder(file)) {
        return;
      }
      const emlContent = await this.app.vault.read(file);
      const email = parseEml(emlContent);
      const attachmentFolder = this.getAttachmentFolder(file);
      const attachmentLinks = await this.saveAttachments(email, file, attachmentFolder);
      let movedEmlName = null;
      if (this.settings.emlHandling === "move-to-attachments") {
        movedEmlName = await this.moveEmlToAttachments(file, attachmentFolder);
      }
      const markdown = this.generateMarkdown(email, attachmentLinks, movedEmlName);
      await this.app.vault.create(mdPath, markdown);
      if (this.settings.emlHandling === "delete") {
        await this.app.vault.delete(file);
      }
      new import_obsidian2.Notice(`Converted: ${file.name}`);
    } catch (error) {
      console.error("EML conversion error:", error);
      new import_obsidian2.Notice(`Failed to convert ${file.name}: ${error.message}`);
    } finally {
      this.processingFiles.delete(file.path);
    }
  }
  /**
   * Move the EML file to the attachments folder
   */
  async moveEmlToAttachments(file, attachmentFolder) {
    await this.ensureFolderExists(attachmentFolder);
    const baseName = file.basename;
    let newName = file.name;
    let newPath = attachmentFolder ? (0, import_obsidian2.normalizePath)(`${attachmentFolder}/${newName}`) : newName;
    let counter = 1;
    while (this.app.vault.getAbstractFileByPath(newPath)) {
      newName = `${baseName}_${counter}.eml`;
      newPath = attachmentFolder ? (0, import_obsidian2.normalizePath)(`${attachmentFolder}/${newName}`) : newName;
      counter++;
    }
    await this.app.fileManager.renameFile(file, newPath);
    return newName;
  }
  /**
   * Save attachments to the attachment folder using Vault API
   */
  async saveAttachments(email, sourceFile, attachmentFolder) {
    const attachmentLinks = /* @__PURE__ */ new Map();
    if (email.attachments.length === 0) {
      return attachmentLinks;
    }
    await this.ensureFolderExists(attachmentFolder);
    const baseName = sourceFile.basename;
    for (const attachment of email.attachments) {
      try {
        if (attachment.content.length > MAX_ATTACHMENT_SIZE) {
          continue;
        }
        const safeName = this.sanitizeFilename(attachment.filename);
        const attachmentName = `${baseName}_${safeName}`;
        const attachmentPath = attachmentFolder ? (0, import_obsidian2.normalizePath)(`${attachmentFolder}/${attachmentName}`) : attachmentName;
        if (this.app.vault.getAbstractFileByPath(attachmentPath)) {
          attachmentLinks.set(attachment.filename, attachmentName);
          if (attachment.contentId) {
            attachmentLinks.set(`cid:${attachment.contentId}`, attachmentName);
          }
          continue;
        }
        await this.app.vault.createBinary(attachmentPath, attachment.content);
        attachmentLinks.set(attachment.filename, attachmentName);
        if (attachment.contentId) {
          attachmentLinks.set(`cid:${attachment.contentId}`, attachmentName);
        }
      } catch (error) {
        console.error(`Attachment save failed for ${attachment.filename}:`, error);
      }
    }
    return attachmentLinks;
  }
  /**
   * Sanitize filename for safe file system use
   */
  sanitizeFilename(filename) {
    return filename.replace(/[<>:"/\\|?*]/g, "_").replace(/\s+/g, "_").replace(/_+/g, "_").substring(0, 200);
  }
  /**
   * Format date according to settings
   */
  formatDate(date) {
    if (!date || isNaN(date.getTime())) {
      return "";
    }
    const format = this.settings.dateFormat;
    const pad = (n) => n.toString().padStart(2, "0");
    return format.replace("YYYY", date.getFullYear().toString()).replace("MM", pad(date.getMonth() + 1)).replace("DD", pad(date.getDate())).replace("HH", pad(date.getHours())).replace("mm", pad(date.getMinutes())).replace("ss", pad(date.getSeconds()));
  }
  /**
   * Format date as ISO string for frontmatter
   */
  formatDateISO(date) {
    if (!date || isNaN(date.getTime())) {
      return "";
    }
    return date.toISOString();
  }
  /**
   * Generate attachment list markdown
   */
  generateAttachmentList(attachmentLinks) {
    const lines = [];
    if (attachmentLinks.size === 0) {
      return lines;
    }
    lines.push("### Attachments");
    lines.push("");
    attachmentLinks.forEach((linkName, originalName) => {
      var _a;
      if (originalName.startsWith("cid:")) {
        return;
      }
      const ext = ((_a = linkName.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
      const isImage = ["png", "jpg", "jpeg", "gif", "webp", "svg", "bmp"].includes(ext);
      if (isImage) {
        lines.push(`- ![[${linkName}]]`);
      } else {
        lines.push(`- [[${linkName}]]`);
      }
    });
    lines.push("");
    return lines;
  }
  /**
   * Generate Markdown content from parsed email
   */
  generateMarkdown(email, attachmentLinks, movedEmlName) {
    const lines = [];
    if (this.settings.useFrontmatter) {
      lines.push("---");
      if (email.from.length > 0) {
        lines.push(`from: "${this.escapeYaml(formatEmailAddresses(email.from))}"`);
      }
      if (email.to.length > 0) {
        lines.push(`to: "${this.escapeYaml(formatEmailAddresses(email.to))}"`);
      }
      if (email.cc.length > 0) {
        lines.push(`cc: "${this.escapeYaml(formatEmailAddresses(email.cc))}"`);
      }
      if (email.bcc.length > 0) {
        lines.push(`bcc: "${this.escapeYaml(formatEmailAddresses(email.bcc))}"`);
      }
      if (email.date) {
        lines.push(`date: ${this.formatDateISO(email.date)}`);
      }
      if (email.subject) {
        lines.push(`subject: "${this.escapeYaml(email.subject)}"`);
      }
      if (email.messageId) {
        lines.push(`message_id: "${this.escapeYaml(email.messageId)}"`);
      }
      lines.push("type: email");
      lines.push("---");
      lines.push("");
    }
    lines.push(`# ${email.subject || "Untitled Email"}`);
    lines.push("");
    if (this.settings.showHeadersInBody) {
      if (email.from.length > 0) {
        lines.push(`**From:** ${formatEmailAddresses(email.from)}`);
      }
      if (email.to.length > 0) {
        lines.push(`**To:** ${formatEmailAddresses(email.to)}`);
      }
      if (email.cc.length > 0) {
        lines.push(`**CC:** ${formatEmailAddresses(email.cc)}`);
      }
      if (email.date) {
        lines.push(`**Date:** ${this.formatDate(email.date)}`);
      }
      if (movedEmlName && this.settings.linkMovedEml) {
        lines.push(`**Original:** [[${movedEmlName}]]`);
      }
      lines.push("");
      lines.push("---");
      lines.push("");
    }
    const showAttachmentsTop = this.settings.attachmentListPosition === "top" || this.settings.attachmentListPosition === "both";
    const showAttachmentsBottom = this.settings.attachmentListPosition === "bottom" || this.settings.attachmentListPosition === "both";
    if (showAttachmentsTop && attachmentLinks.size > 0) {
      lines.push(...this.generateAttachmentList(attachmentLinks));
      lines.push("---");
      lines.push("");
    }
    let body = "";
    if (email.textBody) {
      body = email.textBody;
    } else if (email.htmlBody) {
      body = htmlToMarkdown(email.htmlBody);
      attachmentLinks.forEach((linkName, cidRef) => {
        if (cidRef.startsWith("cid:")) {
          body = body.replace(
            new RegExp(`!\\[([^\\]]*)\\]\\(${this.escapeRegex(cidRef)}\\)`, "g"),
            `![[${linkName}]]`
          );
        }
      });
    }
    if (body) {
      lines.push(body);
      lines.push("");
    }
    if (showAttachmentsBottom && attachmentLinks.size > 0) {
      lines.push("---");
      lines.push("");
      lines.push(...this.generateAttachmentList(attachmentLinks));
    }
    return lines.join("\n");
  }
  /**
   * Escape YAML special characters
   */
  escapeYaml(str) {
    return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n");
  }
  /**
   * Escape regex special characters
   */
  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
